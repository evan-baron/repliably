generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                           Int              @id @default(autoincrement())
  auth0Id                      String?          @unique
  email                        String           @unique
  firstName                    String?
  lastName                     String?
  timezone                     String?
  role                         String?
  lastSynced                   DateTime?
  createdAt                    DateTime         @default(now())
  updatedAt                    DateTime         @updatedAt
  defaultAlterSubjectLine      Boolean          @default(false)
  defaultReferencePrevious     Boolean          @default(true)
  defaultRequireApproval       Boolean          @default(true)
  defaultSendDelay             Int?             @default(2)
  defaultSequenceDuration      Int?             @default(60)
  defaultSequenceType          Int              @default(3)
  notificationBounce           Boolean          @default(true)
  notificationMessageApproval  Boolean          @default(true)
  notificationSendFailure      Boolean          @default(true)
  notificationSequenceComplete Boolean          @default(true)
  trackEmailOpens              Boolean          @default(true)
  trackLinkClicks              Boolean          @default(true)
  subscriptionTier             SubscriptionTier @default(free)
  active                       Boolean          @default(true)
  connectedEmail               String?
  emailConnectedAt             DateTime?
  emailConnectionActive        Boolean          @default(false)
  emailTokenExpiresAt          DateTime?
  gmailRefreshToken            String?
  gmailWatchAllowed            Boolean          @default(false)
  gmailWatchExpiration         DateTime?
  gmailHistoryId               String?
  contacts                     Contact[]
  emailReplies                 EmailReply[]
  messages                     Message[]
  sequences                    Sequence[]
  templates                    Template[]
  signatures                   UserSignature[]
}

model Contact {
  id             Int          @id @default(autoincrement())
  email          String
  firstName      String?
  lastName       String?
  company        String?
  phone          String?
  reasonForEmail String?
  active         Boolean      @default(false)
  lastActivity   DateTime?
  replied        Boolean      @default(false)
  validEmail     Boolean?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  autoCreated    Boolean      @default(false)
  ownerId        Int
  importance     Int?
  linkedIn       String?
  title          String?
  owner          User         @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  emailReplies   EmailReply[]
  messages       Message[]
  sequences      Sequence[]   @relation("ContactSequences")
}

model Message {
  id                   Int           @id @default(autoincrement())
  contactId            Int
  ownerId              Int
  sequenceId           Int?
  templateId           Int?
  subject              String
  contents             String        @db.VarChar(5000)
  direction            String
  hasReply             Boolean       @default(false)
  inReplyTo            String?
  messageId            String?
  replyDate            DateTime?
  threadId             String?
  needsApproval        Boolean?
  lastError            String?
  scheduledAt          DateTime?
  sendAttempts         Int           @default(0)
  sentAt               DateTime?
  status               MessageStatus @default(scheduled)
  createdAt            DateTime      @default(now())
  approvalDeadline     DateTime?
  approved             Boolean?
  needsFollowUp        Boolean       @default(false)
  nextMessageGenerated Boolean       @default(false)
  contact              Contact       @relation(fields: [contactId], references: [id], onDelete: Cascade)
  owner                User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  sequence             Sequence?     @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  template             Template?     @relation("TemplateMessages", fields: [templateId], references: [id])

  @@index([status, scheduledAt])
}

model EmailReply {
  id                Int       @id @default(autoincrement())
  contactId         Int
  replyContent      String
  replyDate         DateTime
  processed         Boolean   @default(false)
  createdAt         DateTime  @default(now())
  originalMessageId String
  replyMessageId    String
  ownerId           Int
  replySubject      String
  replyHistory      String?
  sequenceId        Int?
  threadId          String
  isAutomated       Boolean   @default(false)
  contact           Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  owner             User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  sequence          Sequence? @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  isBounce          Boolean   @default(false)
}

model Sequence {
  id                     Int          @id @default(autoincrement())
  contactId              Int
  ownerId                Int
  sequenceType           String
  autoSend               Boolean      @default(false)
  autoSendDelay          Int?
  currentStep            Int          @default(0)
  nextStepDue            DateTime?
  active                 Boolean      @default(true)
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt
  endDate                DateTime?
  sequenceDuration       Int?         @default(30)
  title                  String
  alterSubjectLine       Boolean?
  referencePreviousEmail Boolean?
  emailReplies           EmailReply[]
  messages               Message[]
  contact                Contact      @relation("ContactSequences", fields: [contactId], references: [id], onDelete: Cascade)
  owner                  User         @relation(fields: [ownerId], references: [id], onDelete: Cascade)
}

model Job {
  id        Int       @id @default(autoincrement())
  type      String
  payload   Json
  status    String    @default("pending")
  attempts  Int       @default(0)
  runAt     DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Template {
  id          Int       @id @default(autoincrement())
  userId      Int
  name        String
  subject     String
  content     String
  contentType String    @default("quill")
  category    String?
  isDefault   Boolean   @default(false)
  isActive    Boolean   @default(true)
  usageCount  Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  messages    Message[] @relation("TemplateMessages")
  owner       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserSignature {
  id        Int      @id @default(autoincrement())
  userId    Int
  name      String
  content   String
  isDefault Boolean  @default(false)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  owner     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Waitlist {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  createdAt DateTime @default(now())
}

enum MessageStatus {
  scheduled
  pending
  sent
  failed
  cancelled
  processing
}

model RateLimit {
  id          Int      @id @default(autoincrement())
  identifier  String
  bucket      String
  windowStart DateTime
  count       Int      @default(1)

  @@unique([identifier, bucket])
  @@index([windowStart])
}

enum SubscriptionTier {
  free
  basic
  pro
  elite
}
